<!DOCTYPE html>
<html lang="en">

<head>
  <title>Shader drop</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
  <div id="overlay">
    <button id="startButton">Start Demo</button>
  </div>
  <div id="info">
    <a rel="noopener">Drop shader<br /></a>
  </div>

  <script id="vertexShader" type="x-shader/x-vertex">
      uniform float time;
      uniform vec2 resolution;
      uniform vec2 dropPosition;
      void main()	{
          gl_Position = vec4(position, 1.0 );
      }
    </script>

  <script id="fragmentShader" type="x-shader/x-fragment">
      uniform vec2 resolution;
      uniform float time;
      uniform vec2 dropPosition;

      void main() {
        // center the shader
        vec2 st = gl_FragCoord.xy/resolution.xy - vec2(0.5);
        vec3 color = vec3(0.5);


        // shader functionality
        //float x = mod(time + gl_FragCoord.x, 20.) < 10. ? 1. : 0.;
        //float y = mod(time + gl_FragCoord.y, 20.) < 10. ? 1. : 0.;
        //color = vec3(min(x, y));


        // color for position
        //if (st.x > dropPosition.x) {color = vec3(0,0,1);}
        //if (st.y > dropPosition.y) {color = vec3(1,0,0);}

        // color the frame we can see that it take up the whole screen.
        if (st.x > 0.99) {color = vec3(0,0,1);}
        if (st.x < 0.01) {color = vec3(1,0,0);}
        if (st.y > 0.99) {color = vec3(0,0,1);}
        if (st.y < 0.01) {color = vec3(1,0,0);}

        // make cross
        if (st.x > 0.45 && st.x < 0.55) {color = vec3(1,1,1);}
        if (st.y > 0.45 && st.y < 0.55) {color = vec3(1,1,1);}

        // make moving cross
        if (st.x > dropPosition.x && st.x < dropPosition.x+0.1) {color = vec3(1,0,0);}
        if (st.y > dropPosition.y && st.y < dropPosition.y+0.1) {color = vec3(0,1,0);}
        //color = vec3(dropPosition.x);

        gl_FragColor = vec4(color, 1.);
    }
   </script>

  <script type="module">

    import * as THREE from './build/three.module.js'
    import { DeviceOrientationControls } from './jsm/controls/DeviceOrientationControls.js';
    console.log("hello");

    let camera, scene, renderer, controls;
    var startTime;
    var uniforms, material2, mesh2;
    let camera2;

    //const startButton = document.getElementById('startButton');
    //startButton.addEventListener('click', function () {
      init();
      animate();
      startTime = Date.now();
    //}, false);

    function init() {
      /* SETUP */
      const overlay = document.getElementById('overlay');
      overlay.remove();


      camera2 = new THREE.Camera();
      camera2.position.z = 1;

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
      
      
      controls = new DeviceOrientationControls(camera);
      scene = new THREE.Scene();


      /* GEOMETRICAL LINES */
      /*
      const helperGeometry = new THREE.BoxBufferGeometry( 100, 100, 100, 4, 4, 4 );
      const helperMaterial = new THREE.MeshBasicMaterial( { color: 0xff00ff, wireframe: true } );
      const helper = new THREE.Mesh( helperGeometry, helperMaterial );
      scene.add( helper );
      */

      /* SHADER STUFF */
      uniforms = {
        time: { type: "f", value: 1.0 },
        resolution: { type: "v2", value: new THREE.Vector2() },
        dropPosition: { type: "v2", value: new THREE.Vector2() }
      };

      material2 = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent
      });

      mesh2 = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material2);
      scene.add(mesh2);

      uniforms.resolution.value.x = window.innerWidth;
      uniforms.resolution.value.y = window.innerHeight;
      uniforms.dropPosition.value.x = 0.5;
      uniforms.dropPosition.value.y = 0.5;
      /* END SHADER STUFF */


      /*
      const geometry = new THREE.SphereBufferGeometry(500, 60, 40);
      // invert the geometry on the x-axis so that all of the faces point inward
      geometry.scale(- 1, 1, 1);

      const material = new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('textures/2294472375_24a3b8ef46_o.jpg')
      });

      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);
      */

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', onWindowResize, false);
    }

    function animate() {
      window.requestAnimationFrame(animate);
      controls.update();
      render();
    }

    function render() {
      var elapsedMilliseconds = Date.now() - startTime;
      var elapsedSeconds = elapsedMilliseconds / 1000.;
      uniforms.time.value = 60. * elapsedSeconds;
      console.log(controls.object);
      console.log("cam get world: ");
      console.log(camera.getWorldDirection());
      uniforms.dropPosition.value.x = camera.getWorldDirection().x;
      uniforms.dropPosition.value.y = camera.getWorldDirection().y;
      // render static cam
      renderer.render(scene, camera2);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      uniforms.resolution.value.x = window.innerWidth;
      uniforms.resolution.value.y = window.innerHeight;
      renderer.setSize(window.innerWidth, window.innerHeight);      
    }
  </script>


</body>

</html>


<!--

<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      margin: 0px;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <script src="build/three.min.js"></script>
  
  <script id="vertexShader" type="x-shader/x-vertex">
        uniform float time;
        uniform vec2 resolution;
        void main()	{
            gl_Position = vec4( position, 1.0 );
        }
    </script>

  <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec2 resolution;
        void main()	{
            float x = mod(time + gl_FragCoord.x, 20.) < 10. ? 1. : 0.;
            float y = mod(time + gl_FragCoord.y, 20.) < 10. ? 1. : 0.;
            gl_FragColor = vec4(vec3(min(x, y)), 1.);
        }
    </script>
  <script>
    var container;
    var camera, scene, renderer;
    var uniforms, material, mesh;
    var mouseX = 0, mouseY = 0,
      lat = 0, lon = 0, phy = 0, theta = 0;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    init();
    var startTime = Date.now();
    animate();

    function init() {
      container = document.getElementById('container');

      camera = new THREE.Camera();
      camera.position.z = 1;
      scene = new THREE.Scene();

      uniforms = {
        time: { type: "f", value: 1.0 },
        resolution: { type: "v2", value: new THREE.Vector2() }
      };

      material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent
      });

      mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
      scene.add(mesh);

      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
      container.appendChild(renderer.domElement);

      uniforms.resolution.value.x = window.innerWidth;
      uniforms.resolution.value.y = window.innerHeight;
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      render();
    }

    function render() {
      var elapsedMilliseconds = Date.now() - startTime;
      var elapsedSeconds = elapsedMilliseconds / 1000.;
      uniforms.time.value = 60. * elapsedSeconds;
      renderer.render(scene, camera);
    }
  </script>
</body>

</html>
-->