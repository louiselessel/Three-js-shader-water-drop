<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title hidden> Julius Bär </title>
  <style>
    #demo-div {
      color: lightgrey;
      border-radius: 0.9rem;
    }

    #demo-div span,
    #demo-div #num-observed-events {
      color: black;
    }

    h1 {
      margin-top: 0.0rem;
    }

    h4 {
      margin-top: 0.0rem;
      font-size: 1.33rem;
    }

    #demo-div li {
      line-height: 21px;
    }

    #demo-div ul {
      margin-bottom: 0.0rem;
    }
  </style>
</head>

<body>
  <main role="main" class="container">
    <h1 hidden align="left">Julius Bär</h1>

    <script id="vertexShader" type="x-shader/x-vertex">

      varying vec2 vUv;
      uniform float iTime;
      uniform vec2 iResolution;
      uniform vec2 dropPosition;
      uniform sampler2D iChannel0;

      void main()	{
        //gl_Position = vec4(position, 1.0 );
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
      varying vec2 vUv;

      uniform vec2 iResolution;
      uniform float iTime;
      uniform vec2 dropPosition;
      //vec2 dropPosition = vec2(0.5,0.5);

      uniform sampler2D iChannel0;
      
      #define S(x, y, z)	smoothstep(x, y, z)
      #define TWOPI	6.283

      
      float random(float val, float f1, float f2) {
        return fract(sin(val*f1)*f2);
      }

      vec2 Drop(vec2 uv, float t) {
        t *= 4.;							// scale time
        
        vec2 a = vec2 (1.,1);			// aspect of grid cell
        a = vec2(iResolution.x/iResolution.y); // aspect of grid cell based on image
        
        // st used for main drop - uv used for additional drops
        vec2 st = uv*a;					// uv to aspect
        
        // grid cell id's
        vec2 id = floor(st);
        
        // position of drop
        float y = 0.0;
        float x = 0.0;								// x location in grid
        
        x = dropPosition.x;           // from external
        y = dropPosition.y;
        vec2 p1 = vec2(x, y);						// set position, y only
        
        // make it round
        vec2 offset1 = (p1-st) / a;				// offset inside box to follow box, used for getting uv
        float d = length(offset1);				// distance to center of box
        float mask1 = S(.02, .1, d);			// mask to make fuzzy or not
        
        // strength, makes uv mask scaled + makes ofsett different for each pixel
        float sm1 = 30.;
        
        // make drops
        vec2 drops = vec2(mask1*offset1*sm1);	
        
        return vec2(drops);
      }

      vec2 DropReflection(vec2 drops, float l0, float l1, float l2) {
          float s; 		// = StaticDrops(uv, t)*l0; 
          vec2 m1; 		// = DropLayer2(uv, t)*l1;
          //vec2 m2 = DropLayer2(uv*1.85, t)*l2;
          vec2 m2;
          m1 = drops;
          
          float c = s+m1.x+m2.x;
          //c = S(.3, 1., c);
          
          return vec2(c, m1.y);//max(m1.y*l0, m2.y*l1));
      }

      void main()
      {
          vec2 uv = (gl_FragCoord.xy/iResolution.xy)*0.5 -0.5;
          //(gl_FragCoord.xy-.5*iResolution.xy) / iResolution.y;
          vec2 UV = gl_FragCoord.xy/iResolution.xy * 0.5;
          
          //FROM ORIGINAL: vec2 st = (gl_FragCoord.xy /resolution.xy) *.5;

          // Time
          float T = iTime; // + M.x*2.;
          float t = T*.2;

        // Make drops with UVs
          vec2 dropDistort = Drop(uv, T);
          
          // MAKE REFLECTIONS
          float layer1 = S(.25, .75, 0.3);
          vec2 c = DropReflection(dropDistort, layer1, 0., 0.);
          vec2 e = vec2(.001, 0.);
          
          vec2 dropDistort1 = Drop(uv+e, T);
          vec2 dropDistort2 = Drop(uv+e.yx, T);
          float cx = DropReflection(dropDistort1, layer1, 0., 0.).x;
          float cy = DropReflection(dropDistort2, layer1, 0., 0.).x;

          // n IS THE DROP
          //float cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;
          //float cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;
          vec2 n = vec2(cx-c.x, cy-c.x);		// expensive normals
          

          float rainAmount = 0.3;				// also adjusts the amount of blur -  min= 0.3
    
          // MAKE THE BLUR
          float maxBlur = mix(3., 6., rainAmount);
          float minBlur = 1.;
          // APPLY THE BLUR
          float focus = mix((maxBlur-c.y)*0.5*0.5, minBlur, S(.1, .2, c.y));
          //focus = mix((maxBlur-c.y)*0.5*0.5, minBlur, S(.1, .2, c.y-0.5));
          //focus = mix((maxBlur-c.x)*0.5*0.5, minBlur, S(.1, .2, c.x-0.5));
          //focus = mix((maxBlur-c.x)*0.5*0.5, focus, S(.1, .2, c.x-0.5));
          focus *= 0.5;
    
          // drop + blur
          vec4 col = texture2D(iChannel0, vUv+n, focus); 
          
          //vec4 col = f;
          //col = vec4(dropDistort, 0, 1.);
          // col += vec4(dropDistort, 0, 1.);     // UV DEBUG
          
          //if (uv.y > 0.49) {col = vec4(1.0,0.0,0.0,1.0);}   // check that mapping of uv is -0.5 to 0.5
          
          //f = texture(iChannel0, (u - v1.xy) * .3);
          //fragColor = col;  
          gl_FragColor = col;    
      }

   </script>

    <!-- THREE JS MODULE -->
    <script type="module">
      import * as THREE from './build/three.module.js'
      console.log("hello");

      let scene, renderer, controls;
      var startTime;
      var uniforms, material, mesh;
      let camera;
      //const textureIn = new THREE.TextureLoader().load( "./textures/Lorem_Ipsum_Univers55.png" );
      const iMouse = new THREE.Vector2();
      const dropPos = new THREE.Vector2();
      const last_dropPos = new THREE.Vector2();
      var maxforce = 4; // float
      var maxspeed = 0.1; // float
      var mass = 0.001;
      var location = new THREE.Vector2(0,0);
      var acceleration = new THREE.Vector2(0,0);
      var velocity = new THREE.Vector2(0,0);
      
      init();
      animate();
      startTime = Date.now();


      function onMouseMove( event ) {

        // calculate mouse position in normalized device coordinates
        // (-0.5 to +0.5) for both components

        iMouse.x = ( event.clientX / window.innerWidth ) - 0.5;
        iMouse.y = (( event.clientY / window.innerHeight ) - 0.5) * -1.;
        //console.log(iMouse.y);
        updateFieldIfNotNull('Mouse_X', iMouse.x);
        updateFieldIfNotNull('Mouse_Y', iMouse.y);
      }

      function applyForce(force) {
        var f = new THREE.Vector2(0,0);
        f = force.divideScalar(mass); //Receive a force, divide by mass, and add to acceleration.
        acceleration.add(f);
        //return f;
      }

      function seek(target) {
        var desired = new THREE.Vector2(0,0);
        // console.log('location_seek');
        // console.log(location.x);
        desired = target.sub(location);
        //desired.subVectors(target,location);
        //desired = target.distanceTo(location);
        //console.log('desired.x');
        //console.log(desired.x);
        desired.normalize();
        //console.log(desired.x);
        desired.multiplyScalar(maxspeed);
        //console.log(desired.x);
        var steer = new THREE.Vector2(0,0);
        steer = desired.sub(velocity);
        // console.log('steer.x');
        // console.log(steer.x);
        // console.log(velocity);
        steer.clampLength ( 0, maxforce);
        //console.log('steer.x');
        //console.log(steer.x);
        applyForce(steer);
      }

      /*
      function arrive(PVector target) {
        PVector desired = PVector.sub(target,location);
        float d = desired.mag(); //The distance is the magnitude of the vector pointing from location to target.
        desired.normalize();
        //If we are closer than 100 pixels...
        if (d < 100) {
          //...set the magnitude according to how close we are.
          float m = map(d,0,100,0,maxspeed);
          desired.mult(m);
        } else {
          //Otherwise, proceed at maximum speed.
          desired.mult(maxspeed);
        }
    
        //The usual steering = desired - velocity
        PVector steer = PVector.sub(desired,velocity);
        steer.limit(maxforce);
        applyForce(steer);
      }
      */

      // FRICTION UNDER IMPLEMENTATION

      function calcForces(posX,posY, forceX, forceY) {
        // additional forces
        //var gravity = THREE.Vector2(0,0.1); // force example
        var force = new THREE.Vector2(forceX,forceY); // force
        //var f = applyForce(force);
        //console.log(force);

        // seek target
        var target = new THREE.Vector2( posX, posY );
        //console.log('target');
        //console.log(target);
        seek(target);

        var test = new THREE.Vector2(1.,1);
        // update location
        //velocity.add(test);
        velocity.add(acceleration);

        velocity.clampLength ( 0, maxspeed);
        // console.log('velo');
        // console.log(velocity);
        location.add(velocity);

        //console.log(velocity);
        // console.log('l');
        // console.log(location);
        acceleration.multiplyScalar(0); //zero out acceleration
        //console.log('acc ZERO');
        //console.log(acceleration);
        return location;
      }



      function init() {
        /* SETUP */
        camera = new THREE.Camera();
        camera.position.z = 1.;
        scene = new THREE.Scene();
        location = new THREE.Vector2(0,0);
        console.log('location_init');
        console.log(location.x);
        acceleration = new THREE.Vector2(0,0);
        velocity = new THREE.Vector2(0,0);

        /* SHADER STUFF */
        uniforms = {
          iTime: { type: "f", value: 1.0 },
          iResolution: { type: "v2", value: new THREE.Vector2() },
          dropPosition: { type: "v2", value: new THREE.Vector2() },
          iChannel0: { type: "t", value: new THREE.TextureLoader().load('textures/app_background_1080x1920.jpg') }
        };


        //uniforms[ "textureIn" ].value.wrapS = uniforms[ "texture" ].value.wrapT = THREE.RepeatWrapping;

        material = new THREE.ShaderMaterial({
          uniforms: uniforms,
          vertexShader: document.getElementById('vertexShader').textContent,
          fragmentShader: document.getElementById('fragmentShader').textContent
        });

        mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
        scene.add(mesh);

        uniforms.iResolution.value.x = window.innerWidth;
        uniforms.iResolution.value.y = window.innerHeight;
        uniforms.dropPosition.value.x = 0.0;
        uniforms.dropPosition.value.y = 0.0;
        /* END SHADER STUFF */

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener( 'mousemove', onMouseMove, false );
      }

      function animate() {
        window.requestAnimationFrame(animate);
        render();
      }

      function render() {
        var elapsedMilliseconds = Date.now() - startTime;
        var elapsedSeconds = elapsedMilliseconds / 1000.;
        uniforms.iTime.value = 60. * elapsedSeconds;

        last_dropPos.x = dropPos.x;
        last_dropPos.y = dropPos.y;

        // set info
        var x = document.getElementById('Orientation_g').innerHTML;
        var y = document.getElementById('Orientation_b').innerHTML;
        var xAccel = document.getElementById('Accelerometer_x').innerHTML;
        var yAccel = document.getElementById('Accelerometer_y').innerHTML;
        var gyroVal = 60;
        if (x != null && x < gyroVal && x > -gyroVal) {
          var valx = clamp_map(x, -gyroVal, gyroVal, -0.5, 0.5);
          dropPos.x = valx;
          updateFieldIfNotNull('Mapped_X', valx);
        }
        if (y != null && y < gyroVal && y > -gyroVal) {
          var valy = clamp_map(y, gyroVal, -gyroVal, -0.5, 0.5);
          dropPos.y = valy;
          updateFieldIfNotNull('Mapped_Y', valy);
        }

        // MOUSE DEBUG
        //dropPos.x = iMouse.x;
        //dropPos.y = iMouse.y;
        //console.log(dropPos.x);
        //console.log('loc');
        //console.log(location.x);

        //var scalarVec = new THREE.Vector2(0,0);
        //scalarVec = dropPos.distanceTo(last_dropPos);
        //console.log(scalarVec);

        //uniforms.dropPosition.value.x = dropPos.x; 
        //uniforms.dropPosition.value.y = dropPos.y; 

        // var newPos = new THREE.Vector2(0,0);
        // newPos = calcForces(dropPos.x,dropPos.y, 1.0, 1.0);  // target position
        // console.log('newPos');
        // console.log(newPos);

        //uniforms.dropPosition.value.x = newPos.x; 
        //uniforms.dropPosition.value.y = newPos.y; 


        uniforms.dropPosition.value.x = dropPos.x; 
        uniforms.dropPosition.value.y = dropPos.y; 




        // render static cam
        renderer.render(scene, camera);
      }




      function updateFieldIfNotNull(fieldName, value, precision = 10) {
        if (value != null)
          document.getElementById(fieldName).innerHTML = value.toFixed(precision);
      }

      function clamp_map(value, min1, max1, min2, max2) {
        let newVal = 0.;
        newVal = min2 + (value - min1) * (max2 - min2) / (max1 - min1);
        if (newVal < min2) { newVal = min2; }
        if (newVal > max2) { newVal = max2; }
        return newVal;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        uniforms.iResolution.value.x = window.innerWidth;
        uniforms.iResolution.value.y = window.innerHeight;
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    </script>

    <div class="p-3 mb-2 bg-secondary" id="demo-div">
      <a  id="start_demo" class="btn btn-lg btn-success py-1" href="#" role="button">Start the demo</a>
      <p hidden style="margin-top:1rem;">Num. of datapoints: <span class="badge badge-warning"
          id="num-observed-events">0</span></p>

      <ul hidden> 
        <li>X-axis (&beta;): <span id="Orientation_b">0</span><span>&deg;</span></li>
        <li>Y-axis (&gamma;): <span id="Orientation_g">0</span><span>&deg;</span></li>
        <li>Z-axis (&alpha;): <span id="Orientation_a">0</span><span>&deg;</span></li>

        <li>mapped X: <span id="Mapped_X">0</span></li>
        <li>mapped Y: <span id="Mapped_Y">0</span></li>
        <li>mouseX: <span id="Mouse_X">0</span></li>
        <li>mouseY: <span id="Mouse_Y">0</span></li>

      </ul>
      
      <h4 hidden>Accelerometer</h4>
      <ul hidden>
        <li>X-axis: <span id="Accelerometer_x">0</span><span> m/s<sup>2</sup></span></li>
        <li>Y-axis: <span id="Accelerometer_y">0</span><span> m/s<sup>2</sup></span></li>
        <li>Z-axis: <span id="Accelerometer_z">0</span><span> m/s<sup>2</sup></span></li>
        <li>Data Interval: <span id="Accelerometer_i">0</span><span> ms</span></li>
      </ul>

      <h4 hidden>Accelerometer including gravity</h4>
      <ul hidden>
        <li>X-axis: <span id="Accelerometer_gx">0</span><span> m/s<sup>2</sup></span></li>
        <li>Y-axis: <span id="Accelerometer_gy">0</span><span> m/s<sup>2</sup></span></li>
        <li>Z-axis: <span id="Accelerometer_gz">0</span><span> m/s<sup>2</sup></span></li>
      </ul>

      <h4 hidden>Gyroscope</h4>
      <ul hidden>
        <li>X-axis: <span id="Gyroscope_x">0</span><span>&deg;/s</span></li>
        <li>Y-axis: <span id="Gyroscope_y">0</span><span>&deg;/s</span></li>
        <li>Z-axis: <span id="Gyroscope_z">0</span><span>&deg;/s</span></li>
      </ul>
      
    </div>
  </main>


  <!-- PHONE MOVEMENT -->
  <script>
    function handleOrientation(event) {
      updateFieldIfNotNull('Orientation_a', event.alpha);
      updateFieldIfNotNull('Orientation_b', event.beta);
      updateFieldIfNotNull('Orientation_g', event.gamma);
      incrementEventCount();
    }

    function incrementEventCount() {
      let counterElement = document.getElementById("num-observed-events")
      let eventCount = parseInt(counterElement.innerHTML)
      counterElement.innerHTML = eventCount + 1;
    }

    function updateFieldIfNotNull(fieldName, value, precision = 10) {
      if (value != null)
        document.getElementById(fieldName).innerHTML = value.toFixed(precision);
    }

    function handleMotion(event) {
      updateFieldIfNotNull('Accelerometer_gx', event.accelerationIncludingGravity.x);
      updateFieldIfNotNull('Accelerometer_gy', event.accelerationIncludingGravity.y);
      updateFieldIfNotNull('Accelerometer_gz', event.accelerationIncludingGravity.z);

      updateFieldIfNotNull('Accelerometer_x', event.acceleration.x);
      updateFieldIfNotNull('Accelerometer_y', event.acceleration.y);
      updateFieldIfNotNull('Accelerometer_z', event.acceleration.z);

      updateFieldIfNotNull('Accelerometer_i', event.interval, 500); //millis

      updateFieldIfNotNull('Gyroscope_z', event.rotationRate.alpha);
      updateFieldIfNotNull('Gyroscope_x', event.rotationRate.beta);
      updateFieldIfNotNull('Gyroscope_y', event.rotationRate.gamma);
      incrementEventCount();
    }


    let is_running = false;
    let demo_button = document.getElementById("start_demo");

    // Button click will TO BE REMOVED
    window.onload = function (e) {
      e.preventDefault();
      // Request permission for iOS 13+ devices
      if (
        DeviceMotionEvent &&
        typeof DeviceMotionEvent.requestPermission === "function"
      ) {
        DeviceMotionEvent.requestPermission();
      }

      // if (is_running) {
      //   window.removeEventListener("devicemotion", handleMotion);
      //   window.removeEventListener("deviceorientation", handleOrientation);
      //   demo_button.innerHTML = "Start demo";
      //   demo_button.classList.add('btn-success');
      //   demo_button.classList.remove('btn-danger');
      //   is_running = false;
      // } else {
        window.addEventListener("devicemotion", handleMotion);
        window.addEventListener("deviceorientation", handleOrientation);
        // document.getElementById("start_demo").innerHTML = "Stop demo";
        // demo_button.classList.remove('btn-success');
        // demo_button.classList.add('btn-danger');
        // is_running = true;
      }
    };

    demo_button.onclick = function (e) {
      e.preventDefault();
      // Request permission for iOS 13+ devices
      if (
        DeviceMotionEvent &&
        typeof DeviceMotionEvent.requestPermission === "function"
      ) {
        DeviceMotionEvent.requestPermission();
      }

      if (is_running) {
        window.removeEventListener("devicemotion", handleMotion);
        window.removeEventListener("deviceorientation", handleOrientation);
        demo_button.innerHTML = "Start demo";
        demo_button.classList.add('btn-success');
        demo_button.classList.remove('btn-danger');
        is_running = false;
      } else {
        window.addEventListener("devicemotion", handleMotion);
        window.addEventListener("deviceorientation", handleOrientation);
        document.getElementById("start_demo").innerHTML = "Stop demo";
        demo_button.classList.remove('btn-success');
        demo_button.classList.add('btn-danger');
        is_running = true;
      }
    };
  </script>
</body>

</html>