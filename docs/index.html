<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title> Shader drop demo </title>
  <style>
    #demo-div {
      color: lightgrey;
      border-radius: 0.3rem;
    }

    #demo-div span,
    #demo-div #num-observed-events {
      color: black;
    }

    h1 {
      margin-top: 0.5rem;
    }

    h4 {
      margin-top: 0.66rem;
      font-size: 1.33rem;
    }

    #demo-div li {
      line-height: 21px;
    }

    #demo-div ul {
      margin-bottom: 0.66rem;
    }
  </style>
</head>

<body>
  <main role="main" class="container">
    <h1 align="left">Shader drop demo</h1>

    <script id="vertexShader" type="x-shader/x-vertex">

      varying vec2 vUv;
      uniform float iTime;
      uniform vec2 iResolution;
      uniform vec2 dropPosition;
      uniform sampler2D iChannel0;

      void main()	{
        //gl_Position = vec4(position, 1.0 );
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">

      varying vec2 vUv;

      uniform vec2 iResolution;
      uniform float iTime;
      uniform vec2 dropPosition;
      //vec2 dropPosition = vec2(0.5,0.5);
      //const float threshold = 0.01;
      //float aRadius = 0.1;

      uniform sampler2D iChannel0;
      
      #define S(x, y, z)	smoothstep(x, y, z)
      #define TWOPI	6.283

      
      float random(float val, float f1, float f2) {
        return fract(sin(val*f1)*f2);
      }

      vec2 Drop(vec2 uv, float t) {
        t *= 4.;							// scale time
        //uv *= .20;						// scale of grid
        //uv += 0.1;

        vec2 a = vec2 (1.,1.);			// aspect of grid cell
        //a = vec2(iResolution.x/iResolution.y); // aspect of grid cell based on image
        
        // st used for main drop - uv used for additional drops
        vec2 st = uv*a;					// uv to aspect
        
        // grid cell id's
        vec2 id = floor(st);
        
        // offset grid to look more random
        float noise = random(id.x, 716.34, 768.34);
        //st.y += noise;					// offset main drop
        //uv.y += noise;					// offset trail drops
        
        // make the grid move with time
        //st.y += t*0.22;						// move the grid to fit the drop fall

        // we messed with the offset, so redo the grid id
        //id = floor(st);
        
        // center drop in grid
        //st = fract(st) - 0.5; 				// move drop in center of a grid
        
        // offset timing of drops
        //t+= fract( sin(id.x*71.2 + id.y*1453) *768.9) *TWOPI; 	// * TWOPI to get complete phase shift
        
        // position of drop
        float y = 0.0;
        //y = -sin(t+sin(t+sin(t)*0.5)) * 0.43;	// move up slow fast down -  a curve
        float x = 0.0;								// x location in grid
        //x = 0.5-0.5; 
        //y = 0.5-0.5; 
        x = dropPosition.x;
        y = dropPosition.y;
        vec2 p1 = vec2(x, y);						// set position, y only
        
        // make it round
        vec2 offset1 = (p1-st) / a;				// offset inside box to follow box, used for getting uv
        float d = length(offset1);				// distance to center of box
        float mask1 = S(.02, .06, d);			// mask to make fuzzy or not
        
        // make more circles
        vec2 offset2 = (fract(uv*a.x*vec2(1.,2.)) -.5) / vec2(1.,2.);
        d = length(uv);					// circle in center of image
        d = length(fract(uv*a.x) -.5);	// smaller circles in each grid
        d = length(fract(uv*a.x*vec2(1.,2.)) -.5);		// squeze them in y (make twice the amount) 
        d = length((fract(uv*a.x*vec2(1.,2.)) -.5)/ vec2(1.,2.));		// make round again
        d = length(offset2);
        
        
        float maskDropDirection = S(-.1,.1, st.y-p1.y);		// mask for drops above the current p1
        float mask2 = S(.07, .06, d);
        mask2 = S(.2*(.5-st.y), .0, d);	// fuzzy, distance applied
        mask2 *= maskDropDirection;		// mask applied on drops
        
        //if (st.x > .48|| st.y > 0.49 ) { mask1 = 1.;}		// show grid
        
        // strength, makes uv mask scaled + makes ofsett different for each pixel
        float sm1 = 30.;
        float sm2 = 20.;
        
        // make drops
        vec2 drops = vec2(mask1*offset1*sm1);	
        //drops += vec2(mask2*offset2*sm2);
        
        return vec2(drops);
      }

      vec2 DropReflection(vec2 drops, float l0, float l1, float l2) {
          float s; 		// = StaticDrops(uv, t)*l0; 
          vec2 m1; 		// = DropLayer2(uv, t)*l1;
          //vec2 m2 = DropLayer2(uv*1.85, t)*l2;
          vec2 m2;
          m1 = drops;
          
          float c = s+m1.x+m2.x;
          //c = S(.3, 1., c);
          
          return vec2(c, m1.y);//max(m1.y*l0, m2.y*l1));
      }

      void main()
      {
          vec2 uv = (gl_FragCoord.xy/iResolution.xy)*0.5 -0.5;
          //(gl_FragCoord.xy-.5*iResolution.xy) / iResolution.y;
          vec2 UV = gl_FragCoord.xy/iResolution.xy * 0.5;
          
          //FROM ORIGINAL: vec2 st = (gl_FragCoord.xy /resolution.xy) *.5;
          
          //M = dropPosition.xy; ///iResolution.xy;
          //dropPosition.xy = M.xy;

          // Time
          float T = iTime; // + M.x*2.;
          float t = T*.2;

        // Make drops with UVs
          vec2 dropDistort = Drop(uv, T);
          
          // MAKE REFLECTIONS
          float layer1 = S(.25, .75, 0.3);
          vec2 c = DropReflection(dropDistort, layer1, 0., 0.);
          vec2 e = vec2(.001, 0.);
          
          vec2 dropDistort1 = Drop(uv+e, T);
          vec2 dropDistort2 = Drop(uv+e.yx, T);
          float cx = DropReflection(dropDistort1, layer1, 0., 0.).x;
          float cy = DropReflection(dropDistort2, layer1, 0., 0.).x;

          //float cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;
          //float cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;
          vec2 n = vec2(cx-c.x, cy-c.x);		// expensive normals
          
          vec4 col = texture2D(iChannel0, vUv+n); //  textureLod(iChannel0, UV+n, 1.);
          //color = texture2D(iChannel0, vUv).rgb;
          
          
          //vec4 col = f;
          //col = vec4(dropDistort, 0, 1.);
          col += vec4(dropDistort, 0, 1.);
          
          //if (uv.y > 0.49) {col = vec4(1.0,0.0,0.0,1.0);}   // check that mapping of uv is -0.5 to 0.5
          
          //f = texture(iChannel0, (u - v1.xy) * .3);
          //fragColor = col;  
          gl_FragColor = col;    
      }

   </script>

    <!-- THREE JS MODULE -->
    <script type="module">
      import * as THREE from './build/three.module.js'
      console.log("hello");

      let scene, renderer, controls;
      var startTime;
      var uniforms, material, mesh;
      let camera;
      //const textureIn = new THREE.TextureLoader().load( "./textures/Lorem_Ipsum_Univers55.png" );
      const iMouse = new THREE.Vector2();
      
      init();
      animate();
      startTime = Date.now();


      function onMouseMove( event ) {

        // calculate mouse position in normalized device coordinates
        // (-0.5 to +0.5) for both components

        iMouse.x = ( event.clientX / window.innerWidth ) - 0.5;
        iMouse.y = (( event.clientY / window.innerHeight ) - 0.5) * -1.;
        console.log(iMouse.y);
      }

      function init() {
        /* SETUP */
        camera = new THREE.Camera();
        camera.position.z = 1.;
        scene = new THREE.Scene();

        /* SHADER STUFF */
        uniforms = {
          iTime: { type: "f", value: 1.0 },
          iResolution: { type: "v2", value: new THREE.Vector2() },
          dropPosition: { type: "v2", value: new THREE.Vector2() },
          iChannel0: { type: "t", value: new THREE.TextureLoader().load('textures/app_background_1080x1920.jpg') }
        };


        //uniforms[ "textureIn" ].value.wrapS = uniforms[ "texture" ].value.wrapT = THREE.RepeatWrapping;

        material = new THREE.ShaderMaterial({
          uniforms: uniforms,
          vertexShader: document.getElementById('vertexShader').textContent,
          fragmentShader: document.getElementById('fragmentShader').textContent
        });

        mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
        scene.add(mesh);

        uniforms.iResolution.value.x = window.innerWidth;
        uniforms.iResolution.value.y = window.innerHeight;
        uniforms.dropPosition.value.x = 0.5;
        uniforms.dropPosition.value.y = 0.5;
        /* END SHADER STUFF */

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener( 'mousemove', onMouseMove, false );
      }

      function animate() {
        window.requestAnimationFrame(animate);
        render();
      }

      function render() {
        var elapsedMilliseconds = Date.now() - startTime;
        var elapsedSeconds = elapsedMilliseconds / 1000.;
        uniforms.iTime.value = 60. * elapsedSeconds;

        // set info
        var x = document.getElementById('Orientation_g').innerHTML;
        var y = document.getElementById('Orientation_b').innerHTML;
        var gyroVal = 60;
        if (x != null && x < gyroVal && x > -gyroVal) {
          var valx = clamp_map(x, -gyroVal, gyroVal, -0.5, 0.5);
          uniforms.dropPosition.value.x = valx;
          updateFieldIfNotNull('Mapped_X', valx);
        }
        if (y != null && y < gyroVal && y > -gyroVal) {
          var valy = clamp_map(y, gyroVal, -gyroVal, -0.5, 0.5);
          uniforms.dropPosition.value.y = valy;
          updateFieldIfNotNull('Mapped_Y', valy);
        }

        // debug with mouse
        //uniforms.dropPosition.value.y = iMouse.y;
        //uniforms.dropPosition.value.x = iMouse.x;


        // render static cam
        renderer.render(scene, camera);
      }



      function updateFieldIfNotNull(fieldName, value, precision = 10) {
        if (value != null)
          document.getElementById(fieldName).innerHTML = value.toFixed(precision);
      }

      function clamp_map(value, min1, max1, min2, max2) {
        let newVal = 0.;
        newVal = min2 + (value - min1) * (max2 - min2) / (max1 - min1);
        if (newVal < min2) { newVal = min2; }
        if (newVal > max2) { newVal = max2; }
        return newVal;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        uniforms.iResolution.value.x = window.innerWidth;
        uniforms.iResolution.value.y = window.innerHeight;
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    </script>

    <div class="p-3 mb-2 bg-secondary" id="demo-div">
      <a id="start_demo" class="btn btn-lg btn-success py-1" href="#" role="button">Start the demo</a>
      <p style="margin-top:1rem;">Num. of datapoints: <span class="badge badge-warning"
          id="num-observed-events">0</span></p>

      <ul>
        <li>X-axis (&beta;): <span id="Orientation_b">0</span><span>&deg;</span></li>
        <li>Y-axis (&gamma;): <span id="Orientation_g">0</span><span>&deg;</span></li>
        <li>Z-axis (&alpha;): <span id="Orientation_a">0</span><span>&deg;</span></li>

        <li>mapped X: <span id="Mapped_X">0</span></li>
        <li>mapped Y: <span id="Mapped_Y">0</span></li>

      </ul>
      <!--
      <h4>Accelerometer</h4>
      <ul>
        <li>X-axis: <span id="Accelerometer_x">0</span><span> m/s<sup>2</sup></span></li>
        <li>Y-axis: <span id="Accelerometer_y">0</span><span> m/s<sup>2</sup></span></li>
        <li>Z-axis: <span id="Accelerometer_z">0</span><span> m/s<sup>2</sup></span></li>
        <li>Data Interval: <span id="Accelerometer_i">0</span><span> ms</span></li>
      </ul>

      <h4>Accelerometer including gravity</h4>
      <ul>
        <li>X-axis: <span id="Accelerometer_gx">0</span><span> m/s<sup>2</sup></span></li>
        <li>Y-axis: <span id="Accelerometer_gy">0</span><span> m/s<sup>2</sup></span></li>
        <li>Z-axis: <span id="Accelerometer_gz">0</span><span> m/s<sup>2</sup></span></li>
      </ul>

      <h4>Gyroscope</h4>
      <ul>
        <li>X-axis: <span id="Gyroscope_x">0</span><span>&deg;/s</span></li>
        <li>Y-axis: <span id="Gyroscope_y">0</span><span>&deg;/s</span></li>
        <li>Z-axis: <span id="Gyroscope_z">0</span><span>&deg;/s</span></li>
      </ul>
      -->
    </div>
  </main>


  <!-- PHONE MOVEMENT -->
  <script>
    function handleOrientation(event) {
      updateFieldIfNotNull('Orientation_a', event.alpha);
      updateFieldIfNotNull('Orientation_b', event.beta);
      updateFieldIfNotNull('Orientation_g', event.gamma);
      incrementEventCount();
    }

    function incrementEventCount() {
      let counterElement = document.getElementById("num-observed-events")
      let eventCount = parseInt(counterElement.innerHTML)
      counterElement.innerHTML = eventCount + 1;
    }

    function updateFieldIfNotNull(fieldName, value, precision = 10) {
      if (value != null)
        document.getElementById(fieldName).innerHTML = value.toFixed(precision);
    }

    function handleMotion(event) {
      updateFieldIfNotNull('Accelerometer_gx', event.accelerationIncludingGravity.x);
      updateFieldIfNotNull('Accelerometer_gy', event.accelerationIncludingGravity.y);
      updateFieldIfNotNull('Accelerometer_gz', event.accelerationIncludingGravity.z);

      updateFieldIfNotNull('Accelerometer_x', event.acceleration.x);
      updateFieldIfNotNull('Accelerometer_y', event.acceleration.y);
      updateFieldIfNotNull('Accelerometer_z', event.acceleration.z);

      updateFieldIfNotNull('Accelerometer_i', event.interval, 2);

      updateFieldIfNotNull('Gyroscope_z', event.rotationRate.alpha);
      updateFieldIfNotNull('Gyroscope_x', event.rotationRate.beta);
      updateFieldIfNotNull('Gyroscope_y', event.rotationRate.gamma);
      incrementEventCount();
    }


    let is_running = false;
    let demo_button = document.getElementById("start_demo");

    // Button click will TO BE REMOVED

    demo_button.onclick = function (e) {
      e.preventDefault();
      // Request permission for iOS 13+ devices
      if (
        DeviceMotionEvent &&
        typeof DeviceMotionEvent.requestPermission === "function"
      ) {
        DeviceMotionEvent.requestPermission();
      }

      if (is_running) {
        //window.removeEventListener("devicemotion", handleMotion);
        window.removeEventListener("deviceorientation", handleOrientation);
        demo_button.innerHTML = "Start demo";
        demo_button.classList.add('btn-success');
        demo_button.classList.remove('btn-danger');
        is_running = false;
      } else {
        //window.addEventListener("devicemotion", handleMotion);
        window.addEventListener("deviceorientation", handleOrientation);
        document.getElementById("start_demo").innerHTML = "Stop demo";
        demo_button.classList.remove('btn-success');
        demo_button.classList.add('btn-danger');
        is_running = true;
      }
    };
  </script>
</body>

</html>