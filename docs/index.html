<!--

<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      margin: 0px;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <script src="build/three.min.js"></script>
  
  <script id="vertexShader" type="x-shader/x-vertex">
        uniform float time;
        uniform vec2 resolution;
        void main()	{
            gl_Position = vec4( position, 1.0 );
        }
    </script>

  <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec2 resolution;
        void main()	{
            float x = mod(time + gl_FragCoord.x, 20.) < 10. ? 1. : 0.;
            float y = mod(time + gl_FragCoord.y, 20.) < 10. ? 1. : 0.;
            gl_FragColor = vec4(vec3(min(x, y)), 1.);
        }
    </script>
  <script>
    var container;
    var camera, scene, renderer;
    var uniforms, material, mesh;
    var mouseX = 0, mouseY = 0,
      lat = 0, lon = 0, phy = 0, theta = 0;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    init();
    var startTime = Date.now();
    animate();

    function init() {
      container = document.getElementById('container');

      camera = new THREE.Camera();
      camera.position.z = 1;
      scene = new THREE.Scene();

      uniforms = {
        time: { type: "f", value: 1.0 },
        resolution: { type: "v2", value: new THREE.Vector2() }
      };

      material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent
      });

      mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
      scene.add(mesh);

      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
      container.appendChild(renderer.domElement);

      uniforms.resolution.value.x = window.innerWidth;
      uniforms.resolution.value.y = window.innerHeight;
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      render();
    }

    function render() {
      var elapsedMilliseconds = Date.now() - startTime;
      var elapsedSeconds = elapsedMilliseconds / 1000.;
      uniforms.time.value = 60. * elapsedSeconds;
      renderer.render(scene, camera);
    }
  </script>
</body>

</html>
-->


<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Shader drop</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="overlay">
			<button id="startButton">Start Demo</button>
		</div>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - equirectangular panorama demo with DeviceOrientation controls.<br/>
			photo by <a href="http://www.flickr.com/photos/jonragnarsson/2294472375/" target="_blank" rel="noopener">JÃ³n Ragnarsson</a>.
		</div>

    <script id="vertexShader" type="x-shader/x-vertex">
      uniform float time;
      uniform vec2 resolution;
      void main()	{
          gl_Position = vec4( position, 1.0 );
      }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
      uniform float time;
      uniform vec2 resolution;
      void main()	{
          float x = mod(time + gl_FragCoord.x, 20.) < 10. ? 1. : 0.;
          float y = mod(time + gl_FragCoord.y, 20.) < 10. ? 1. : 0.;
          gl_FragColor = vec4(vec3(min(x, y)), 1.);
      }
   </script>

		<script type="module">


      import * as THREE from './build/three.module.js'
      import { DeviceOrientationControls } from './jsm/controls/DeviceOrientationControls.js';
      console.log("hello");

      let camera, scene, renderer, controls;
      var startTime;
      var uniforms, material2, mesh2;

			const startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', function () {

				init();
        animate();
        startTime = Date.now();
        

			}, false );

			function init() {
        /* SETUP */
				const overlay = document.getElementById( 'overlay' );
				overlay.remove();

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
        
				controls = new DeviceOrientationControls( camera );

        scene = new THREE.Scene();


        

        /* SHADER STUFF */
        uniforms = {
          time: { type: "f", value: 1.0 },
          resolution: { type: "v2", value: new THREE.Vector2() }
        };

        material2 = new THREE.ShaderMaterial({
          uniforms: uniforms,
          vertexShader: document.getElementById('vertexShader').textContent,
          fragmentShader: document.getElementById('fragmentShader').textContent
        });

        mesh2 = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material2);
        /*scene.add(mesh2);*/

        uniforms.resolution.value.x = window.innerWidth;
        uniforms.resolution.value.y = window.innerHeight;
        /* END SHADER STUFF */



				const geometry = new THREE.SphereBufferGeometry( 500, 60, 40 );
				// invert the geometry on the x-axis so that all of the faces point inward
				geometry.scale( - 1, 1, 1 );

				const material = new THREE.MeshBasicMaterial( {
					map: new THREE.TextureLoader().load( 'textures/2294472375_24a3b8ef46_o.jpg' )
				} );

				const mesh = new THREE.Mesh( geometry, material);
        scene.add( mesh );
        


        /* GEOMETRICAL LINES */
        /*
				const helperGeometry = new THREE.BoxBufferGeometry( 100, 100, 100, 4, 4, 4 );
				const helperMaterial = new THREE.MeshBasicMaterial( { color: 0xff00ff, wireframe: true } );
				const helper = new THREE.Mesh( helperGeometry, helperMaterial );
        scene.add( helper );
        */

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );


			}

			function animate() {

				window.requestAnimationFrame( animate );

				controls.update();
        renderer.render( scene, camera );
        render();
        console.log(camera.getWorldDirection());

      }

      function render() {
      var elapsedMilliseconds = Date.now() - startTime;
      var elapsedSeconds = elapsedMilliseconds / 1000.;
      uniforms.time.value = 60. * elapsedSeconds;
      renderer.render(scene, camera);
      }

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

		</script>
	</body>
</html>
